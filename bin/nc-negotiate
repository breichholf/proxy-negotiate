#!/usr/bin/env python

import argparse
import os

try:
    from urlparse import urlparse
except ImportError:
    from urllib.parse import urlparse

from proxy_negotiate import netcat


def proxy_host_from_env():
    if 'HTTPS_PROXY' in os.environ:
        return urlparse(os.environ['HTTPS_PROXY']).hostname
    elif 'HTTP_PROXY' in os.environ:
        return urlparse(os.environ['HTTP_PROXY']).hostname
    else:
        raise RuntimeError('No PROXY environment variable set.')


def proxy_port_from_env():
    if 'HTTPS_PROXY' in os.environ:
        return urlparse(os.environ['HTTPS_PROXY']).port
    elif 'HTTP_PROXY' in os.environ:
        return urlparse(os.environ['HTTP_PROXY']).port
    else:
        raise RuntimeError('No PROXY environment variable set.')


def main():
    default_proxy = f"{proxy_host_from_env()}:{proxy_port_from_env()}"

    parser = argparse.ArgumentParser(
        description='A thin netcat implementation that handles Proxy '
                    'Authentication for applications that cannot do so on their'
                    'own.')
    parser.add_argument('host', metavar='TARGET:PORT',
                        help='Hostname or IP to tunnel a connection to. '
                             'Provide in format of hostname:port')
    parser.add_argument('proxy', metavar='PROXY:PORT', nargs="?",
                        default=default_proxy,
                        help='Address/hostname of the proxy and port. '
                             'Provide in format hostname:port')
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Add verbose output")
    args = parser.parse_args()

    host, port = urlparse(args.target).host, urlparse(args.target).port
    proxy_host, proxy_port = urlparse(args.proxy).host, urlparse(args.proxy).port

    netcat(host, port, proxy_host, proxy_port, args.verbose)


if __name__ == "__main__":
    main()
